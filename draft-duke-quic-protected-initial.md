---
title: Protected QUIC Initial Packets
abbrev: protected-initial
docname: draft-duke-quic-protected-initial-latest
category: std
ipr: trust200902
area: Transport
workgroup: quic

stand_alone: yes
pi: [toc, sortrefs, symrefs, docmapping]

author:
  -
    ins: M. Duke
    name: Martin Duke
    org: F5 Networks, Inc.
    email: martin.h.duke@gmail.com

normative:

informative:

--- abstract

QUIC encrypts its Initial Packets using keys derived from well-known constants,
meaning that observers can inspect the contents of these packets and
successfully spoof them. This document proposes a new version of QUIC that
encrypts Initial Packets more securely by leveraging a Public Key distributed
via the Domain Name System (DNS) or other out-of-band system.

Discussion of this work is encouraged to happen on the QUIC IETF
mailing list [](quic@ietf.org) or on the GitHub repository which
contains the draft:
[](https://github.com/martinduke/quic-version-aliasing).

--- middle

# Introduction

DISCLAIMER: This draft is a preliminary proposal with insufficient security
analysis. It should not be used in production systems.

The QUIC Initial Packet {{!QUIC-TRANSPORT=I-D.ietf-quic-transport}} is encrypted
using a key derived from the Destination Connection ID in the packet cleartext
and a well-known salt (see Section 5.2 of {{!QUIC-TLS=I-D.ietf-quic-tls}}).
Section 7 of that draft describes security vulnerabilities resulting from the
resulting lack of authentication.

This also has privacy implications, as observers can decrypt the packet and
inspect the contents, which contain the TLS Client Hello and Server Hello
Messages ({{?RFC8446}}). The former contains QUIC Transport Parameters, which
reveal even more information about the traffic.

Furthermore, packets vulnerable to deep inspection create an ossification
vector. Intermediaries that expect the contents of these messages to match a
certain format and template might drop packets that do not, preventing the use
of new protocol extensions or improved security protocols.

This document proposes a new version of QUIC where the client obtains a public
key generated by the server and uses it to encrypt a shared secret, sent in the
Initial packet header, that both endpoints can then use to protect Initial
packets.

This mechanism leverages the public key that would be distributed via DNS (or
other out-of-band mechanism) to support Encrypted Client Hello
{{!ECHO=I-D.ietf-tls-esni}}. That design uses Hybrid Public Key Exchange (HPKE)
({{!HPKE=I-D.irtf-cfrg-hpke}} to authenticate some HPKE configuration
information and the "outer client hello" that is in plaintext, while encrypting
the "inner client hello" that contains privacy-sensitive information. This
document uses the widespread configuration that will exist if ECHO is widely
deployed, but only sends the subset of information necessary to seed the QUIC
key generation process.

The version of QUIC described in this specification is identical to QUIC version
1 {{QUIC-TRANSPORT}} except where described in this document.

## Relationship to ECH and Version Aliasing

Encrypted Client Hello {{ECHO}} and QUIC Version Aliasing
{{?VERSION-ALIASING=I-D.duke-quic-version-aliasing}} also exist in the solution
space of concealing parts of the Initial packet exchange from observers. The
following table summarizes the advantages and disadvantages of each.

| Property | ECH | Protected Initials | Version Aliasing |
| :--- | :---: | :---: | :---: |
| Fields Protected | Some of Client Hello | All Initial Payloads | All Initial Payloads |
| Delay when server loses its keys | 1 RTT | 2 RTT | 2 RTT |
| Works with TLS over TCP | Yes | No | No |
| First-connection protection | Yes | Yes | No |
| Prevents Initial packet injection attacks | No | Yes | Yes |
| Symmetric Encryption Only | No | No | Yes |
| Greases the Version Field | No | No | Yes |
| Prevents Retry injection attacks | No | No | Yes |
| No trial decryption | No | No | Yes |

The more complex properties in the table are discussed in
{{security-considerations}}.

Both ECH and Protected Initials are complimentary with Version Aliasing: they
provide a computationally expensive way to protect parts of the Initial packet
during the first connection between client and server, after which Version
Aliasing can protect future exchanges with several additional desirable
properties.

# Conventions

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119 {{?RFC2119}}.

# Key Configuration

The client obtains the Encrypted ClientHello Configuration (ECHConfig) described
in Section 4 of {{ECHO}}, which provides the context that allows protection of
Initial packets. The ECHConfig is available via a DNS record or other out-of-
band system.

# Version Number

The version field in long headers is TBD. Note: for interoperability
exercises, use the provisional value 0xff454900.

# Key Derivation Labels {#labels}

The labels used to derive keying material in {{QUIC-TLS}} change from
"quic key", "quic iv", "quic hp", and "quic ku" to "quicpi key", "quicpi iv",
"quicpi hp", and "quicpi ku", respectively.

# Initial Packet Header

The figure below is presented in the format from {{QUIC-TRANSPORT}}, and adds a
variable-length Encryption Context preceded by a length field:

~~~
Initial Packet {
   Header From (1) = 1,
   Fixed Big (1) = 1,
   Long Packet Type (2) = 0,
   Reserved Bits (2),
   Packet Number Length (2),
   Version (32),
   Destination Connection ID Length (8),
   Destination Connection ID (0..160),
   Source Connection ID Length (8),
   Source Connection ID (0..160),
   Encryption Context Length (8),
   Encryption Context (..),
   Token Length (i),
   Token (..),
   Length (i),
   Packet Number (8..32),
}
~~~

Encryption Context Length: A variable-length integer specifying the length of
the encryption context, in bytes. Servers MUST set this field to zero; a client
that receives a non-zero length MUST either discard the packet or generate a
connection error of type PROTOCOL_VIOLATION.

Clients MUST include a nonzero Encryption Context Length in all Initial packets,
unless executing fallback procedures (see {{fallback}}).

## Encryption Context {#encryption-context}

The encryption context, if nonzero length, has the following format:

~~~
Encryption Context {
    Config ID (8),
    SCKDF (16),
    SCAEADID (16),
    Encapsulated Secret (..),
}
~~~

Config ID: An 8-bit integer identifying the configuration parameters, obtained
from the ECHConfig. This ID implicitly identifies the public key, Key
Encapsulation Mechanism, and the set of symmetric suites from which the
following fields are selected.

SCKDF: Symmetric Cipher Key Derivation Function. The client selects this from
the cipher suites listed in the ECHConfig. This is the cipher used to encrypt
the Initial Packet. The values are listed in Section 7.2 of {{HPKE}}. All
endpoints MUST support HKDF-SHA256 (0x0001), which is used for QUIC Version 1
Initial packets.

SCAEADID: Symmetric Cipher Key Derivation Function. The client selects this
from the cipher suites listed in the ECHConfig. This is the cipher used to
encrypt the Initial Packet. The values are listed in Section 7.3 of {{HPKE}}.
all endpoints MUST support AES-128-GCM (0x0001), which is used for QUIC Version
1 Initial packets.

The Encapsulated Secret is HPKE encapsulated. Its length is inferred from the
Encryption Context Length field.

# Client Packet Protection Procedure

An client extracts the public key pkR and uses it to generate a shared_secret:

~~~
pkR = Deserialize(ECHConfig.contents.public_key)
shared_secret, enc = Encap(pkR)
initial_secret = HKDF-Extract(shared_secret,
        client_dst_connection_id || ECHConfig)
~~~

enc is the Encapsulated Secret, and is written into that subfield of the
Encryption Context Field.

The initial_secret above is used to generate client_initial_secret and
server_initial_secret as described in Section 5.2 of {{QUIC-TLS}}.

When applying header protection, the Context Length and Encryption Context are
not Protected.

This derivation is performed once per connection. Subsequent Initial Packets
use the same keys and the same offset to the packet number, regardless of
additional Encryption Context fields or changed connection IDs.

# Server Packet Protection Procedure {#server-procedure}

The server reads the Config ID and Encapsulated Secret (enc) from the Initial
Packet. It looks up its private key (skR) associated with the Config ID.

Otherwise, the server generates the Initial secrets:

~~~
shared_secret = Decap(enc, skR)
initial_secret = HKDF-Extract(shared_secret,
        client_dst_connection_id || ECHConfig)
~~~

The remainder is identical to the client procedure. All server-generated
Initial packets use the keys generated in this process.

If packet decryption fails, see {{fallback}}.

# Retry Integrity Tag {#retry}

The Retry packet is identical to QUIC version 1, except that
the key and nonce used for the Retry Integrity Tag (Sec 5.8 of
{{!I-D.ietf-quic-tls}} change to:

~~~
secret = 0xe453a2e22377289f08a4458ee1c9a90a4e39696e026372ffc33190b8de5a0123
key = 0xbe0c690b9f66575a1d766b54e368c84e
nonce = 0x461599d35d632bf2239825bb
~~~

# Fallback {#fallback}

When decoding a client Initial packet length, the server may conclude that the
client does not have the server's correct configuration (see
{{server-procedure}}). In this case, it replies with a Fallback packet (see
{{fallback-packet}}), and discards the Initial.

The client checks the hash in the packet against its own record of the Initial
Packet. If they do not match, the packet may have been corrupted, and the client
MAY treat the packet as lost. If they do match, the client MUST assume that it does
not have the correct ECHConfig.

When it has the incorrect config, the client composes a new Client Hello. It
MUST include the public_key_failed transport parameter with the Config ID and
public key it attempted to use. It MUST use a Encryption Context Length of zero,
and encrypt it with keys derived from the fallback salt defined in
{{fallback-packet}}. The Client Hello also MUST include any Retry Token the
previous Initial contained and MAY include a token from a NEW_TOKEN frame.

Note that the fallback salt does not provide confidentiality to the client, and
the client SHOULD NOT include privacy-sensitive information there. See
{{downgrade}} for further discussion of this.

A server interprets a client Initial with a zero-length Encryption Context as
an Initial encrypted with keys derived from the fallback salt and decrypts it
accordingly.

The server checks the Config ID and public key from the public_key_failed
transport parameter to see if it should successfully process a Protected Initial
with these parameters. If it would have, it MUST terminate the connection with a
FAKE_FAILURE_MESSAGE to indicate that there has been an attack.

If the server would not have successfully decoded the packet with those
parameters, it MUST send its own public_key_failed transport parameter to
acknowledge the parameter was successfully processed. It MAY also send a
ECHConfig transport parameter to allow use of Protected Initials in subsequent
connections, a Version Aliasing transport parameter (see {{VERSION-ALIASING}})
to enable a different means of Initial Protection, both, or neither.

If the client does not receive a public_key_failed transport parameter in
response to sending a public_key_failed transport parameter, it MUST terminate
the connection with a TRANSPORT_PARAMETER_ERROR.

The client MUST NOT include the original client hello in its TLS transcript
hash for key computation, as the server has no access to this message.

# The Fallback Packet {#fallback-packet}

The Fallback packet uses the 0x1 packet type code, which it shares with 0RTT.
Since 0RTT is only sent by clients and Fallback is only sent by servers, these
two types are distinguished by the endpoint's role in the handshake.

The packet is encrypted with Initial keys derived from the following well-known
"fallback salt" 0xbd62319ad6eeb17a9ed0d3bf75e37e4a8e7e6ac7, instead of the
shared secret that the server cannot decode.

The format of this packet is TBD. However, it contains a hash of the entire
client Initial packet that triggered the Fail.

# New Transport Parameters

## public_key_failed

The public_key_failed transport parameter allows detection of an attacker
injecting messages to force use of the fallback salt. For details on use,
see {{fallback}}.

Its provisional type is 0x706b66.

When sent by a client, the content of the transport parameter is as follows:

~~~
{
    Config ID (8),
    Public Key (..),
}
~~~

These fields are populated using the ECHConfig that the client attempted to use.
The length of the Public Key is inferred from the length field of the transport
parameter.

When sent by a server, the transport parameter has no value field.

Endpoints MUST respond to a malformed transport parameter by closing the
connection with a TRANSPORT_PARAMETER_ERROR.

Note that this transport parameter is always sent as a result of a fallback from
a Protected Initial, and therefore with a zero-length Encryption Context in the
packet header. Therefore, if received with non-zero-length Encryption Context,
the receiving endpoint MUST terminate the connection with a
TRANSPORT_PARAMETER_ERROR.

## ECHConfig

The ECHConfig transport parameter allows servers to directly provide clients a
valid configuration.

Its provisional type is 0x454348.

Its format is equivalent to ECHConfigList, as defined in Section 4 of {{ECHO}}.

If this transport parameter does not match this format, is received by a server,
or is received in a connection where the client's most recent Initial had a
non-zero-length Encryption Context, the receiver MUST terminate the connection
with a TRANSPORT_PARAMETER_ERROR.

# Intermediaries

In the topology proposed in Section 3.1 of {{ECHO}}, where a client-facing
server has its own public name and potentially fronts a number of independent
domains, only the client-facing server has the private keys. Thus, it modifies
incoming Initial Packets before forwarding to the back-end server.

A common use case of this topology is a load balancer fronting multiple domains
using the same IP address, which makes routing decisions based on the SNI in the
Client Hello.

## Client-Facing Server

The client-facing server is responsible for verifying the Initial packet is
decryptable, and sending a 0-RTT packet (and dropping the Initial) if it is not.

If an incoming client Initial has a non-zero length Encryption Context field,
the client-facing server MUST delete the Encryption Context field, and re-
encrypt the packet with keys derived from the fallback salt.

If the client is using the shared secret, the client-facing server MUST re-
encrypt server Initial packets using keys derived from the shared secret.

Non-Initial packets pass unmodified through the client-facing server.

Note that client-facing servers cannot inspect any packet payloads except for
Initial packets.

## Back-End Server

Back-end servers MUST have an up-to-date copy of the ECHConfigList the client-
facing server is using, though it need not hold the private key, in order to
properly process and generate the relevant transport parameters.

In all other respects they operate as Protected Initial servers.

# Version Negotiation

Note that QUIC version 1 is not compatible with QUIC Protected Initials, as it
does not contain the information necessary to generate subsequent Initial
packets correctly. Conversely, QUIC Protected Initials are compatible with QUIC
version 1. However, since the versions have identical properties after the
Initial packet exchange, there is little value in such a transition.

# Applicability

This version of QUIC provides no change from QUIC version 1 relating to the
capabilities available to applications. Therefore, all Application Layer
Protocol Negotiation (ALPN) ({{?RFC7301}}) codepoints specified to operate over
QUICv1 can also operate over this version of QUIC.

# Security and Privacy Considerations {#security-considerations}

Sections 10.2, 10.3, 10.4, and 10.6 of {{ECHO}} apply to QUIC Protected Initials
as well.

Section 7.8 of {{VERSION-ALIASING}} is also applicable.

## Version Downgrade Attack

An attacker might inject Version Negotiation to force the connection to migrate
to a version of QUIC that does not protect Initials. Endpoints MUST implement
{{!I-D.ietf-quic-version-negotiation}} if they support multiple versions to
mitigate this attack.

Note that detection does not occur until after the client has sent a new,
unprotected Initial. When composing this Initial, the client should therefore
consider the points in {{downgrade}} below.

## Key Loss and Downgrade {#downgrade}

ECH and Protected Initials both rely on shared cryptographic configuration state
between client and server, delivered by an out-of-band method, usually DNS.

In the event this synchronization fails in ECH, the client-facing server can
complete the handshake, authenticate itself against the "public name" in the
unprotected part of the Client Hello, and provide updated configuration state,
allowing a resumed attempt after 1 RTT.

With Protected Initials, when decryption fails there is not enough context to
complete any sort of authentication to update the crypto context. Instead, the
server sends a Fallback packet that causes the client to fall back to keys that
do not offer confidentiality, with which it could connect to the public name and
only then acquire the updated crypto context. Note that this incurs an
additional 1-RTT penalty over ECH, although loss of key synchronization is
hopefully a rare occurrence.

An attacker could inject Fallback packets to force the client to use the
fallback salt and lose confidentiality. The public_key_failed transport
parameter is designed to confirm that the server could have sent the Fallback
packet, thus validating that there is no downgrade attack.

Upon receipt of a Fallback packet, a client SHOULD wait for a probe timeout
(PTO) before sending a client hello using the fallback salt. This verifies that
the attacker can not only observe Initial packets and inject Fallbacks, but also
drop either the client or server Initial.

## Initial Packet Injection

QUIC version 1 handshakes are vulnerable to DoS from observers for the short
interval that endpoints keep Initial keys (usually ~1.5 RTTS), since Initial
Packets are not authenticated. With version aliasing, attackers do not have
the necessary keys to launch such an attack.

QUIC version 1 can use a fixed symmetric cipher for its Initial Packets because
the encryption is not providing true security. As this design aspires to
stonger guarantees, the Encryption Context field of the Initial header provides
the codepoints to enable use of other symmetric ciphers should AES-128-GCM be
compromised in the future. This is to provide cryptographic agility in
accordance with {{?RFC7696}}.

## Retry Injection

This version of QUIC does not improve the security of Retry packets with
respect to QUIC version 1. The Retry Integrity Tag uses a well-known key and
relies on data in the Initial that triggered the Retry. It therefore protects
against transmission errors and injection of Retry packets by off-path attackers
that cannot observe the Initial. To detect Retry packets injected by observers,
it relies on the subsequent exchange of transport parameters.

An attacker that consistently injects Retry packets in front of a server that
also consistently sends Retry can result in a Denial of Service, as clients
cannot accept two Retries in the same connection.

An alternate design would use the shared secret derived from the Client Initial
Packet to generate keys for the Retry Integrity Tag, which would allow the
client to immediately discard Retries injected by other parties. Unfortunately,
this would require servers to perform an asymmetric crypto operation to send a
Retry packet, when in a state where it is likely computationally limited.

It is possible to enhance the security of Retry by assuming this added
computational cost. Such a design could also eliminate the complexity associated
with adding an arbitrary value to the Packet Length field. The purpose of this
addition is to avoid trial decryption to verify the configuration is correct,
but this cost is negligible compared to extracting the shared secret.

# IANA Considerations

## QUIC Version Registry

This document requests that IANA add the following entry to the QUIC version
registry:

Value: TBD

Status: permanent

Specification: This document

Change Controller: IETF

Contact: QUIC WG

## QUIC Transport Parameter Registry

This document requests that IANA add the following two entries to the QUIC
Transport Parameters registry:

| Value | Parameter Name | Specification |
| :---: | :---: | :---: |
| TBD | public_key_failed | This document |
| TBD | ECHConfig | This document |

## QUIC Transport Error Codes Registry

This document requests that IANA add the following entry to the QUIC Transport
Error Codes registry:

Value: TBD

Code: FAKE_FAILURE_MESSAGE

Description: Attacker is forcing insecure Initial

Specification: This document

--- back

# Change Log

> **RFC Editor's Note:** Please remove this section prior to
> publication of a final version of this document.

## since draft-duke-quic-protected-initials-01

* Redesigned fallback again without Version Negotiation

## since draft-duke-quic-protected-initials-00

* Additional text comparing ECH, Version Aliasing
* Adapted to foreground the split-mode use case
* Clarified server initials are encrypted
* Retry keys are no longer generated from the shared secret
* Complete Rewrite of Fallback
* New transport parameters
* Added crypto agility
