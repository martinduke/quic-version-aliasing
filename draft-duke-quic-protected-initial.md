---
title: Protected QUIC Initial Packets
abbrev: protected-initial
docname: draft-duke-quic-protected-initial-latest
category: std
ipr: trust200902
area: Transport
workgroup: quic

stand_alone: yes
pi: [toc, sortrefs, symrefs, docmapping]

author:
  -
    ins: M. Duke
    name: Martin Duke
    org: F5 Networks, Inc.
    email: martin.h.duke@gmail.com

normative:

informative:

--- abstract

QUIC encrypts its Initial Packets using keys derived from well-known constants,
meaning that observers can inspect the contents of these packets and
successfully spoof them. This document proposes a new version of QUIC that
encrypts Initial Packets more securely by leveraging a Public Key distributed
via the Domain Name System (DNS) or other out-of-band system.

Discussion of this work is encouraged to happen on the QUIC IETF
mailing list [](quic@ietf.org) or on the GitHub repository which
contains the draft: 
[](https://github.com/martinduke/quic-version-aliasing).

--- middle

# Introduction

DISCLAIMER: This draft is a preliminary proposal with insufficient security
analysis. It should not be used in production systems.

The QUIC Initial Packet {{!QUIC-TRANSPORT=I-D.ietf-quic-transport}} is encrypted
using a key derived from the Destination Connection ID in the packet cleartext
and a well-known salt (see Section 5.2 of {{!QUIC-TLS=I-D.ietf-quic-tls}}).
Section 7 of that draft describes security vulnerabilities resulting from the
resulting lack of authentication.

This also has privacy implications, as observers can decrypt the packet and
inspect the contents, which contain the TLS Client Hello and Server Hello
Messages ({{?RFC8446}}). The former contains QUIC Transport Parameters, which
reveal even more information about the traffic.

Furthermore, packets vulnerable to deep inspection create an ossification
vector. Intermediaries that expect the contents of these messages to match a
certain format and template might drop packets that do not, preventing the use
of new protocol extensions or improved security protocols.

This document proposes a new version of QUIC where the client obtains a public
key generated by the server and uses it to encrypt a shared secret, sent in the
Initial packet header, that both endpoints can then use to protect Initial
packets.

This mechanism leverages the public key that would be distributed via DNS (or
other out-of-band mechanism) to support Encrypted Client Hello
{{!ECHO=I-D.ietf-tls-esni}}. That design uses Hybrid Public Key Exchange (HPKE)
({{!HPKE=I-D.irtf-cfrg-hpke}} to authenticate some HPKE configuration
information and the "outer client hello" that is in plaintext, while encrypting
the "inner client hello" that contains privacy-sensitive information. This
document uses the widespread configuration that will exist if ECHO is widely
deployed, but only sends the subset of information necessary to seed the QUIC
key generation process.

The version of QUIC described in this specification is identical to QUIC version
1 {{QUIC-TRANSPORT}} except where described in this document.

## Relationship to ECH and Version Aliasing

Encrypted Client Hello {{ECHO}} and QUIC Version Aliasing
{{?VERSION-ALIASING=I-D.duke-quic-version-aliasing}} also exist in the solution
space of concealing parts of the Initial packet exchange from observers. The
following table summarizes the advantages and disadvantages of each.

| Property | ECH | Protected Initials | Version Aliasing |
| :--- | :---: | :---: | :---: |
| Fields Protected | Some of Client Hello | All Initial Payloads | All Initial Payloads |
| Delay when server loses its keys | 1 RTT | 2 RTT | 2 RTT |
| Works with TLS over TCP | Yes | No | No |
| Attacker cannot force use of public SNI | Yes | No | No |
| First-connection protection | Yes | Yes | No |
| All-Symmetric Encryption | No | No | Yes |
| Greases the Version Field | No | No | Yes |
| All state exchange in-band | No | No | Yes |
| Prevents Initial packet injection attacks | No | Yes | Yes |
| Prevents Retry injection attacks | No | No | Yes |

Initial packet injection attacks are described in Section 21.2 of
{{QUIC-TRANSPORT}}.

Both ECH and Protected Initials are complimentary with Version Aliasing: they
both provide a computationally expensive way to protect parts of the Initial
packet during the first connection between client and server, , after which
Version Aliasing can protect future exchanges with several desirable properties.

# Conventions

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in RFC 2119 {{?RFC2119}}.

# Key Configuration

The client obtains the Encrypted ClientHello Configuration (ECHConfig) described
in Section 4 of {{ECHO}}, which provides the context that allows protection of
Initial packets. The ECHConfig is available via a DNS record or other out-of-
band system.

# Version Number

The version field in long headers is TBD. Note: for interoperability
exercises, use the provisional value 0xff454900.

# Key Derivation Labels {#labels}

The labels used to derive keying material in {{QUIC-TLS}} change from
"quic key", "quic iv", "quic hp", and "quic ku" to "quicpi key", "quicpi iv",
"quicpi hp", and "quicpi ku", respectively.

# Initial Packet Header

The figure below is presented in the format from {{QUIC-TRANSPORT}}, and adds a
variable-length Encryption Context preceded by a length field:

~~~
Initial Packet {
   Header From (1) = 1,
   Fixed Big (1) = 1,
   Long Packet Type (2) = 0,
   Reserved Bits (2),
   Packet Number Length (2),
   Version (32),
   Destination Connection ID Length (8),
   Destination Connection ID (0..160),
   Source Connection ID Length (8),
   Source Connection ID (0..160),
   Encryption Context Length (8),
   Encryption Context (..),
   Token Length (i),
   Token (..),
   Length (i),
   Packet Number (8..32),
}
~~~

Encryption Context Length: A variable-length integer specifying the length of
the encryption context, in bytes. Servers MUST set this field to zero; a client
that receives a non-zero length MUST either discard the packet or generate a
connection error of type PROTOCOL_VIOLATION.

If a client has received a valid Server Initial packet, it SHOULD set this field
to zero. Until then, clients MUST use a nonzero value.  If a client Initial
packet has a zero Encryption Context Length, and the server has not sent an
Initial Packet, the server MUST either discard the packet or generate a
connection error of type PROTOCOL_VIOLATION.

## Encryption Context

The encryption context, if nonzero length, has the following format:

~~~
Encryption Context {
    Config ID (8),
    Encapsulated Secret (..),
}
~~~

The client obtains the Config ID (an 8-bit unsigned integer) from the ECHConfig.
It corresponds to a public key and Key Encapsulation Mechanism (KEM) that are
not sent over the wire.

The Encapsulated Secret is HPKE encapsulated. Its length is inferred from the
Encryption Context Length field.

# Client Packet Protection Procedure

An client extracts the public key pkR and uses it to generate a shared_secret:

~~~
pkR = Deserialize(ECHConfig.contents.public_key)
shared_secret, enc = Encap(pkR)
initial_secret = HKDF-Extract(shared_secret,
        client_dst_connection_id || ECHConfig)
~~~

enc is the Encapsulated Secret, and is written into that subfield of the
Encryption Context Field.

The initial_secret above is used to generate client_initial_secret and
server_initial_secret as described in Section 5.2 of {{QUIC-TLS}}.

When applying header protection, the Context Length and Encryption Context are
not Protected.

Additionally, the client bitwise-XORs the first eight octets of the Destination
Connection ID with the first eight octets of the public key to form a 64 bit
unsigned integer. This integer is added to the packet length, modulo 2^62, and
written into the packet length field instead of the actual packet length.

This derivation is performed once per connection. Subsequent Initial Packets
use the same keys and the same offset to the packet number, regardless of
additional Encryption Context fields or changed connection IDs.

# Server Packet Protection Procedure

The server reads the Config ID and Encapsulated Secret (enc) from the Initial
Packet. It looks up its private key (skR) associated with the Config ID.

Prior to any other operations, including sending any Retry packet, the server
bitwise-XORs the first eight octets of its public key and the destination
connection ID and subtracts this from the value in the packet length field,
modulo 2^62, to find the true packet length.

Any result that exceeds the size of the received datagram indicates with high
assurance that the client's received ECHConfig does not match the server's
state, possibly due to a misconfiguration. The probability this test results in
a false negative, when an incorrect key generates a result less than the
datagram size, is typically less than 1 in 2^51. The server MUST discard the
packet and SHOULD send a Version Negotiation packet that does not advertise the
current QUIC version, as the endpoints do not have the necessary shared state to
use QUIC Protected Initials.

Otherwise, the server generates the Initial secrets:

~~~
shared_secret = Decap(enc, skR)
initial_secret = HKDF-Extract(shared_secret,
        client_dst_connection_id || ECHConfig)
~~~

The server now has sufficient context to send a Retry packet and MAY choose to
do so at this point (see {{retry}}). If not, it decrypts the Initial packet.

The remainder is identical to the client procedure. All server-generated
Initial packets use the keys generated in this process.

# Retry Integrity Tag {#retry}

The Retry packet is identical to QUIC version 1, except that
the key and nonce used for the Retry Integrity Tag (Sec 5.8 of
{{!I-D.ietf-quic-tls}} change to:

~~~
secret = 0xe453a2e22377289f08a4458ee1c9a90a4e39696e026372ffc33190b8de5a0123
key = 0xbe0c690b9f66575a1d766b54e368c84e
nonce = 0x461599d35d632bf2239825bb
~~~

# Version Negotiation

Endpoints that support QUIC Protected Initials MUST support at least one other
version of QUIC (in case the endpoints cannot agree on the ECHConfig), and
therefore MUST also support {{!I-D.ietf-quic-version-negotiation}}.

In contrast to Section 5 of that document, clients MUST be prepared to receive
a version negotiation packet that contains QUIC Protected Initial, and then
receive a second version negotiation packet that does not, should the attempt
to identify a common ECHConfig fail.

Servers MAY continue to advertise QUIC Protected Initials in its Server
Handshake Version Information, even if shared secret extraction failed, to avoid
tracking state as to which clients have failed such extraction. This does not
effect the Version Downgrade mechanism, which is executed by servers.

Note that QUIC version 1 is not compatible with QUIC Protected Initials, as it
does not contain the information necessary to generate subsequent Initial
packets correctly. Conversely, QUIC Protected Initials are compatible with QUIC
version 1. However, since the versions have identical properties after the
Initial packet exchange, there is little value in such a trasition.

# Intermediaries

Intermediaries that rely on the contents of the Client Hello (e.g., a load
balancer that routes between servers with the same IP address based on the SNI
field in the Client Hello) MUST have access to the ECHConfig and the
corresponding Private Keys, as described in Section 3.1 of {{ECHO}}, to function
properly.

# Applicability

This version of QUIC provides no change from QUIC version 1 relating to the
capabilities available to applications. Therefore, all Application Layer
Protocol Negotiation (ALPN) ({{?RFC7301}}) codepoints specified to operate over
QUICv1 can also operate over this version of QUIC.

# Security and Privacy Considerations

Sections 10.2, 10.3, 10.4, and 10.6 of {{ECHO}} apply to QUIC Protected Initials
as well.

Sections 7.2, 7.7, and 7.8 of {{VERSION-ALIASING}} are also applicable.

# IANA Considerations

This document request that IANA add the following entry to the QUIC version
registry:

Value: TBD

Status: permanent

Specification: This document

Change Controller: IETF

Contact: QUIC WG

--- back

# More secure Retries

This version of QUIC does not improve the security of Retry packets with
respect to QUIC version 1. The Retry Integrity Tag uses a well-known key and
relies on data in the Initial that triggered the Retry. It therefore protects
against transmission errors and injection of Retry packets by off-path attackers
that cannot observe the Initial. To detect Retry packets injected by observers,
it relies on the subsequent exchange of transport parameters.

An attacker that consistently injects Retry packets in front of a server that
also consistently sends Retry can result in a Denial of Service, as clients
cannot accept two Retries in the same connection.

An alternate design would use the shared secret derived from the Client Initial
Packet to generate keys for the Retry Integrity Tag, which would allow the
client to immediately discard Retries injected by other parties. Unfortunately,
this would require servers to perform an asymmetric crypto operation to send a
Retry packet, when in a state where it is likely computationally limited.

It is possible to enhance the security of Retry by assuming this added
computational cost. Such a design could also eliminate the complexity associated
with adding an arbitrary value to the Packet Length field. The purpose of this
addition is to avoid trial decryption to verify the configuration is correct,
but this cost is negligible compared to extracting the shared secret.

# Change Log

> **RFC Editor's Note:** Please remove this section prior to
> publication of a final version of this document.

## since draft-duke-quic-protected-initials-00

* Additional text comparing ECH, Version Aliasing
* Clarified server initials are encrypted
* Retry keys are no longer generated from the shared secret
